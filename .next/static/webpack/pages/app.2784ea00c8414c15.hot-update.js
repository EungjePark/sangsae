"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/app",{

/***/ "(pages-dir-browser)/./components/product-detail-viewer/hooks/useContentEditing.ts":
/*!*********************************************************************!*\
  !*** ./components/product-detail-viewer/hooks/useContentEditing.ts ***!
  \*********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useContentEditing: () => (/* binding */ useContentEditing)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_api_productService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/api/productService */ \"(pages-dir-browser)/./lib/api/productService.ts\");\n/* harmony import */ var _lib_store_productStore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/store/productStore */ \"(pages-dir-browser)/./lib/store/productStore.ts\");\n/* harmony import */ var _hooks_use_toast__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/hooks/use-toast */ \"(pages-dir-browser)/./hooks/use-toast.ts\");\n\n\n\n\nfunction useContentEditing() {\n    // 로컬 상태\n    const [editedContent, setEditedContent] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isEditing, setIsEditing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [editingSection, setEditingSection] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // 토스트 훅 사용\n    const { toast } = (0,_hooks_use_toast__WEBPACK_IMPORTED_MODULE_3__.useToast)();\n    // Zustand 스토어에서 필요한 상태와 액션 가져오기 - 각각 개별적으로 가져오기\n    const updateSectionContent = (0,_lib_store_productStore__WEBPACK_IMPORTED_MODULE_2__.useProductStore)({\n        \"useContentEditing.useProductStore[updateSectionContent]\": (state)=>state.updateSectionContent\n    }[\"useContentEditing.useProductStore[updateSectionContent]\"]);\n    const targetCustomers = (0,_lib_store_productStore__WEBPACK_IMPORTED_MODULE_2__.useProductStore)({\n        \"useContentEditing.useProductStore[targetCustomers]\": (state)=>state.targetCustomers\n    }[\"useContentEditing.useProductStore[targetCustomers]\"]);\n    const productCategory = (0,_lib_store_productStore__WEBPACK_IMPORTED_MODULE_2__.useProductStore)({\n        \"useContentEditing.useProductStore[productCategory]\": (state)=>state.productCategory\n    }[\"useContentEditing.useProductStore[productCategory]\"]);\n    const storeGeneratedContent = (0,_lib_store_productStore__WEBPACK_IMPORTED_MODULE_2__.useProductStore)({\n        \"useContentEditing.useProductStore[storeGeneratedContent]\": (state)=>state.generatedContent\n    }[\"useContentEditing.useProductStore[storeGeneratedContent]\"]);\n    const startEditing = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useContentEditing.useCallback[startEditing]\": (sectionId, initialContent)=>{\n            setEditingSection(sectionId);\n            setEditedContent(initialContent);\n            setIsEditing(true);\n        }\n    }[\"useContentEditing.useCallback[startEditing]\"], []);\n    const cancelEditing = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useContentEditing.useCallback[cancelEditing]\": ()=>{\n            setEditingSection(null);\n            setEditedContent(null);\n            setIsEditing(null);\n        }\n    }[\"useContentEditing.useCallback[cancelEditing]\"], []);\n    const updateEditedContent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useContentEditing.useCallback[updateEditedContent]\": (content)=>{\n            setEditedContent(content);\n        }\n    }[\"useContentEditing.useCallback[updateEditedContent]\"], []);\n    const saveEdit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useContentEditing.useCallback[saveEdit]\": async (sectionId, generatedContent, setGeneratedContent)=>{\n            if (!sectionId || editedContent === null) return;\n            try {\n                // 만약 외부에서 전달받은 generatedContent와 setGeneratedContent가 있다면 직접 사용\n                if (generatedContent && setGeneratedContent) {\n                    const updatedContent = {\n                        ...generatedContent\n                    };\n                    const sectionIndex = updatedContent.sections.findIndex({\n                        \"useContentEditing.useCallback[saveEdit].sectionIndex\": (s)=>s.id === sectionId\n                    }[\"useContentEditing.useCallback[saveEdit].sectionIndex\"]);\n                    if (sectionIndex !== -1) {\n                        updatedContent.sections[sectionIndex].content = editedContent;\n                        setGeneratedContent(updatedContent);\n                    }\n                } else {\n                    // 그렇지 않으면 Zustand 스토어 사용\n                    updateSectionContent(sectionId, editedContent);\n                }\n                toast({\n                    title: '수정 완료',\n                    description: '섹션 내용이 업데이트되었습니다.',\n                    variant: 'default'\n                });\n                // 편집 상태 초기화\n                cancelEditing();\n            } catch (error) {\n                toast({\n                    title: '수정 실패',\n                    description: '섹션 내용 업데이트 중 오류가 발생했습니다.',\n                    variant: 'destructive'\n                });\n            }\n        }\n    }[\"useContentEditing.useCallback[saveEdit]\"], [\n        editedContent,\n        updateSectionContent,\n        cancelEditing,\n        toast\n    ]);\n    const regenerateSection = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useContentEditing.useCallback[regenerateSection]\": async (sectionId, generatedContent, handleRegenerate)=>{\n            // 외부에서 전달된 generatedContent가 없다면 스토어에서 가져옴\n            const contentToUse = generatedContent || storeGeneratedContent;\n            if (!contentToUse) {\n                toast({\n                    title: '재생성 실패',\n                    description: '생성된 콘텐츠가 없습니다.',\n                    variant: 'destructive'\n                });\n                return;\n            }\n            setEditingSection(sectionId);\n            setIsEditing('regenerating');\n            try {\n                // 외부에서 전달받은 핸들러가 있다면 사용\n                if (handleRegenerate) {\n                    handleRegenerate(sectionId);\n                } else {\n                    // 기존 로직 실행\n                    const cacheName = contentToUse.cacheName || '';\n                    const productName = cacheName.split('_')[0] || 'Product';\n                    // API 호출\n                    const response = await (0,_lib_api_productService__WEBPACK_IMPORTED_MODULE_1__.regenerateSectionApi)({\n                        sectionId,\n                        productInfo: {\n                            name: productName,\n                            category: productCategory,\n                            targetCustomers\n                        }\n                    });\n                    // 응답 처리 (API 응답 구조에 맞게 수정)\n                    if (response.data && response.data.sections && response.data.sections[sectionId]) {\n                        // Zustand 스토어를 통해 섹션 콘텐츠 업데이트\n                        updateSectionContent(sectionId, response.data.sections[sectionId].content);\n                        toast({\n                            title: '재생성 완료',\n                            description: '섹션 내용이 새롭게 생성되었습니다.',\n                            variant: 'default'\n                        });\n                    } else {\n                        throw new Error('섹션 재생성 실패');\n                    }\n                }\n            } catch (error) {\n                console.error('섹션 재생성 오류:', error);\n                const errorMessage = error instanceof Error ? error.message : '알 수 없는 오류가 발생했습니다';\n                toast({\n                    title: '재생성 실패',\n                    description: errorMessage,\n                    variant: 'destructive'\n                });\n            } finally{\n                setIsEditing(null);\n                setEditingSection(null);\n            }\n        }\n    }[\"useContentEditing.useCallback[regenerateSection]\"], [\n        storeGeneratedContent,\n        productCategory,\n        targetCustomers,\n        updateSectionContent,\n        toast\n    ]);\n    return {\n        editedContent,\n        isEditing,\n        editingSection,\n        startEditing,\n        cancelEditing,\n        updateEditedContent,\n        saveEdit,\n        regenerateSection\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvcHJvZHVjdC1kZXRhaWwtdmlld2VyL2hvb2tzL3VzZUNvbnRlbnRFZGl0aW5nLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE4QztBQUdrQjtBQUVMO0FBQ2Q7QUFtQ3RDLFNBQVNLO0lBQ2QsUUFBUTtJQUNSLE1BQU0sQ0FBQ0MsZUFBZUMsaUJBQWlCLEdBQUdQLCtDQUFRQSxDQUFnQjtJQUNsRSxNQUFNLENBQUNRLFdBQVdDLGFBQWEsR0FBR1QsK0NBQVFBLENBQWtDO0lBQzVFLE1BQU0sQ0FBQ1UsZ0JBQWdCQyxrQkFBa0IsR0FBR1gsK0NBQVFBLENBQWdCO0lBRXBFLFdBQVc7SUFDWCxNQUFNLEVBQUVZLEtBQUssRUFBRSxHQUFHUiwwREFBUUE7SUFFMUIsZ0RBQWdEO0lBQ2hELE1BQU1TLHVCQUF1QlYsd0VBQWVBO21FQUFDVyxDQUFBQSxRQUFTQSxNQUFNRCxvQkFBb0I7O0lBQ2hGLE1BQU1FLGtCQUFrQlosd0VBQWVBOzhEQUFDVyxDQUFBQSxRQUFTQSxNQUFNQyxlQUFlOztJQUN0RSxNQUFNQyxrQkFBa0JiLHdFQUFlQTs4REFBQ1csQ0FBQUEsUUFBU0EsTUFBTUUsZUFBZTs7SUFDdEUsTUFBTUMsd0JBQXdCZCx3RUFBZUE7b0VBQUNXLENBQUFBLFFBQVNBLE1BQU1JLGdCQUFnQjs7SUFFN0UsTUFBTUMsZUFBZWxCLGtEQUFXQTt1REFBQyxDQUFDbUIsV0FBbUJDO1lBQ25EVixrQkFBa0JTO1lBQ2xCYixpQkFBaUJjO1lBQ2pCWixhQUFhO1FBQ2Y7c0RBQUcsRUFBRTtJQUVMLE1BQU1hLGdCQUFnQnJCLGtEQUFXQTt3REFBQztZQUNoQ1Usa0JBQWtCO1lBQ2xCSixpQkFBaUI7WUFDakJFLGFBQWE7UUFDZjt1REFBRyxFQUFFO0lBRUwsTUFBTWMsc0JBQXNCdEIsa0RBQVdBOzhEQUFDLENBQUN1QjtZQUN2Q2pCLGlCQUFpQmlCO1FBQ25COzZEQUFHLEVBQUU7SUFFTCxNQUFNQyxXQUFXeEIsa0RBQVdBO21EQUFDLE9BQzNCbUIsV0FDQUYsa0JBQ0FRO1lBRUEsSUFBSSxDQUFDTixhQUFhZCxrQkFBa0IsTUFBTTtZQUUxQyxJQUFJO2dCQUNGLGdFQUFnRTtnQkFDaEUsSUFBSVksb0JBQW9CUSxxQkFBcUI7b0JBQzNDLE1BQU1DLGlCQUFpQjt3QkFBRSxHQUFHVCxnQkFBZ0I7b0JBQUM7b0JBQzdDLE1BQU1VLGVBQWVELGVBQWVFLFFBQVEsQ0FBQ0MsU0FBUztnRkFBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsRUFBRSxLQUFLWjs7b0JBRXJFLElBQUlRLGlCQUFpQixDQUFDLEdBQUc7d0JBQ3ZCRCxlQUFlRSxRQUFRLENBQUNELGFBQWEsQ0FBQ0osT0FBTyxHQUFHbEI7d0JBQ2hEb0Isb0JBQW9CQztvQkFDdEI7Z0JBQ0YsT0FBTztvQkFDTCx5QkFBeUI7b0JBQ3pCZCxxQkFBcUJPLFdBQVdkO2dCQUNsQztnQkFFQU0sTUFBTTtvQkFDSnFCLE9BQU87b0JBQ1BDLGFBQWE7b0JBQ2JDLFNBQVM7Z0JBQ1g7Z0JBRUEsWUFBWTtnQkFDWmI7WUFDRixFQUFFLE9BQU9jLE9BQU87Z0JBQ2R4QixNQUFNO29CQUNKcUIsT0FBTztvQkFDUEMsYUFBYTtvQkFDYkMsU0FBUztnQkFDWDtZQUNGO1FBQ0Y7a0RBQUc7UUFBQzdCO1FBQWVPO1FBQXNCUztRQUFlVjtLQUFNO0lBRTlELE1BQU15QixvQkFBb0JwQyxrREFBV0E7NERBQUMsT0FDcENtQixXQUNBRixrQkFDQW9CO1lBRUEsMkNBQTJDO1lBQzNDLE1BQU1DLGVBQWVyQixvQkFBb0JEO1lBRXpDLElBQUksQ0FBQ3NCLGNBQWM7Z0JBQ2pCM0IsTUFBTTtvQkFDSnFCLE9BQU87b0JBQ1BDLGFBQWE7b0JBQ2JDLFNBQVM7Z0JBQ1g7Z0JBQ0E7WUFDRjtZQUVBeEIsa0JBQWtCUztZQUNsQlgsYUFBYTtZQUViLElBQUk7Z0JBQ0Ysd0JBQXdCO2dCQUN4QixJQUFJNkIsa0JBQWtCO29CQUNwQkEsaUJBQWlCbEI7Z0JBQ25CLE9BQU87b0JBQ0wsV0FBVztvQkFDWCxNQUFNb0IsWUFBWUQsYUFBYUMsU0FBUyxJQUFJO29CQUM1QyxNQUFNQyxjQUFjRCxVQUFVRSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSTtvQkFFL0MsU0FBUztvQkFDVCxNQUFNQyxXQUFXLE1BQU16Qyw2RUFBb0JBLENBQUM7d0JBQzFDa0I7d0JBQ0F3QixhQUFhOzRCQUNYQyxNQUFNSjs0QkFDTkssVUFBVTlCOzRCQUNWRDt3QkFDRjtvQkFDRjtvQkFFQSwyQkFBMkI7b0JBQzNCLElBQUk0QixTQUFTSSxJQUFJLElBQUlKLFNBQVNJLElBQUksQ0FBQ2xCLFFBQVEsSUFBSWMsU0FBU0ksSUFBSSxDQUFDbEIsUUFBUSxDQUFDVCxVQUFVLEVBQUU7d0JBQ2hGLDhCQUE4Qjt3QkFDOUJQLHFCQUFxQk8sV0FBV3VCLFNBQVNJLElBQUksQ0FBQ2xCLFFBQVEsQ0FBQ1QsVUFBVSxDQUFDSSxPQUFPO3dCQUV6RVosTUFBTTs0QkFDSnFCLE9BQU87NEJBQ1BDLGFBQWE7NEJBQ2JDLFNBQVM7d0JBQ1g7b0JBQ0YsT0FBTzt3QkFDTCxNQUFNLElBQUlhLE1BQU07b0JBQ2xCO2dCQUNGO1lBQ0YsRUFBRSxPQUFPWixPQUFPO2dCQUNkYSxRQUFRYixLQUFLLENBQUMsY0FBY0E7Z0JBQzVCLE1BQU1jLGVBQWVkLGlCQUFpQlksUUFBUVosTUFBTWUsT0FBTyxHQUFHO2dCQUU5RHZDLE1BQU07b0JBQ0pxQixPQUFPO29CQUNQQyxhQUFhZ0I7b0JBQ2JmLFNBQVM7Z0JBQ1g7WUFDRixTQUFVO2dCQUNSMUIsYUFBYTtnQkFDYkUsa0JBQWtCO1lBQ3BCO1FBQ0Y7MkRBQUc7UUFBQ007UUFBdUJEO1FBQWlCRDtRQUFpQkY7UUFBc0JEO0tBQU07SUFFekYsT0FBTztRQUNMTjtRQUNBRTtRQUNBRTtRQUNBUztRQUNBRztRQUNBQztRQUNBRTtRQUNBWTtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYXJrZXVuZ2plL0RvY3VtZW50cy9zYW5nc2FlL2NvbXBvbmVudHMvcHJvZHVjdC1kZXRhaWwtdmlld2VyL2hvb2tzL3VzZUNvbnRlbnRFZGl0aW5nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHR5cGUgUHJvZHVjdERldGFpbENvbnRlbnQsIHR5cGUgUHJvZHVjdERldGFpbFNlY3Rpb24sIHR5cGUgUHJvZHVjdENhdGVnb3J5LCB0eXBlIFByb2R1Y3RJbmZvIH0gZnJvbSAnQC90eXBlcy9wcm9kdWN0JztcbmltcG9ydCB7IGNsZWFudXBDb2xvbnMgfSBmcm9tICcuLi91dGlscy9jb250ZW50Rm9ybWF0dGVycyc7XG5pbXBvcnQgeyByZWdlbmVyYXRlU2VjdGlvbkFwaSB9IGZyb20gJ0AvbGliL2FwaS9wcm9kdWN0U2VydmljZSc7XG5pbXBvcnQgeyBUb2FzdEFjdGlvbkVsZW1lbnQgfSBmcm9tICdAL2NvbXBvbmVudHMvdWkvdG9hc3QnO1xuaW1wb3J0IHsgdXNlUHJvZHVjdFN0b3JlIH0gZnJvbSAnQC9saWIvc3RvcmUvcHJvZHVjdFN0b3JlJztcbmltcG9ydCB7IHVzZVRvYXN0IH0gZnJvbSAnQC9ob29rcy91c2UtdG9hc3QnO1xuaW1wb3J0IHsgQXBpRXJyb3JSZXNwb25zZSB9IGZyb20gJ0AvbGliL2FwaS9lcnJvci1oYW5kbGVyJztcblxuLy8gRGVmaW5lIHRoZSBzdHJ1Y3R1cmUgZm9yIHRoZSBlZGl0aW5nIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBFZGl0aW5nU3RhdGVzIHtcbiAgW3NlY3Rpb25JZDogc3RyaW5nXTogYm9vbGVhbiB8ICdyZWdlbmVyYXRpbmcnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVkaXRlZENvbnRlbnRzIHtcbiAgW3NlY3Rpb25JZDogc3RyaW5nXTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRleHRhcmVhUmVmcyB7XG4gIFtzZWN0aW9uSWQ6IHN0cmluZ106IEhUTUxUZXh0QXJlYUVsZW1lbnQgfCBudWxsO1xufVxuXG4vLyBUb2FzdCDtlajsiJgg7YOA7J6FIOygleydmFxuZXhwb3J0IGludGVyZmFjZSBUb2FzdFByb3BzIHtcbiAgdGl0bGU6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgdmFyaWFudD86IFwiZGVmYXVsdFwiIHwgXCJkZXN0cnVjdGl2ZVwiO1xuICBhY3Rpb24/OiBUb2FzdEFjdGlvbkVsZW1lbnQ7XG59XG5cbmV4cG9ydCB0eXBlIENvbnRlbnRFZGl0aW5nSG9vayA9IHtcbiAgZWRpdGVkQ29udGVudDogc3RyaW5nIHwgbnVsbDtcbiAgaXNFZGl0aW5nOiBib29sZWFuIHwgJ3JlZ2VuZXJhdGluZycgfCBudWxsO1xuICBlZGl0aW5nU2VjdGlvbjogc3RyaW5nIHwgbnVsbDtcbiAgc3RhcnRFZGl0aW5nOiAoc2VjdGlvbklkOiBzdHJpbmcsIGluaXRpYWxDb250ZW50OiBzdHJpbmcpID0+IHZvaWQ7XG4gIGNhbmNlbEVkaXRpbmc6ICgpID0+IHZvaWQ7XG4gIHVwZGF0ZUVkaXRlZENvbnRlbnQ6IChjb250ZW50OiBzdHJpbmcpID0+IHZvaWQ7XG4gIHNhdmVFZGl0OiAoc2VjdGlvbklkOiBzdHJpbmcsIGdlbmVyYXRlZENvbnRlbnQ6IFByb2R1Y3REZXRhaWxDb250ZW50IHwgbnVsbCwgc2V0R2VuZXJhdGVkQ29udGVudD86IChjb250ZW50OiBQcm9kdWN0RGV0YWlsQ29udGVudCkgPT4gdm9pZCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgcmVnZW5lcmF0ZVNlY3Rpb246IChzZWN0aW9uSWQ6IHN0cmluZywgZ2VuZXJhdGVkQ29udGVudD86IFByb2R1Y3REZXRhaWxDb250ZW50IHwgbnVsbCwgaGFuZGxlUmVnZW5lcmF0ZT86IChzZWN0aW9uSWQ6IHN0cmluZykgPT4gdm9pZCkgPT4gUHJvbWlzZTx2b2lkPjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VDb250ZW50RWRpdGluZygpOiBDb250ZW50RWRpdGluZ0hvb2sge1xuICAvLyDroZzsu6wg7IOB7YOcXG4gIGNvbnN0IFtlZGl0ZWRDb250ZW50LCBzZXRFZGl0ZWRDb250ZW50XSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbaXNFZGl0aW5nLCBzZXRJc0VkaXRpbmddID0gdXNlU3RhdGU8Ym9vbGVhbiB8ICdyZWdlbmVyYXRpbmcnIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtlZGl0aW5nU2VjdGlvbiwgc2V0RWRpdGluZ1NlY3Rpb25dID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIFxuICAvLyDthqDsiqTtirgg7ZuFIOyCrOyaqVxuICBjb25zdCB7IHRvYXN0IH0gPSB1c2VUb2FzdCgpO1xuICBcbiAgLy8gWnVzdGFuZCDsiqTthqDslrTsl5DshJwg7ZWE7JqU7ZWcIOyDge2DnOyZgCDslaHshZgg6rCA7KC47Jik6riwIC0g6rCB6rCBIOqwnOuzhOyggeycvOuhnCDqsIDsoLjsmKTquLBcbiAgY29uc3QgdXBkYXRlU2VjdGlvbkNvbnRlbnQgPSB1c2VQcm9kdWN0U3RvcmUoc3RhdGUgPT4gc3RhdGUudXBkYXRlU2VjdGlvbkNvbnRlbnQpOyBcbiAgY29uc3QgdGFyZ2V0Q3VzdG9tZXJzID0gdXNlUHJvZHVjdFN0b3JlKHN0YXRlID0+IHN0YXRlLnRhcmdldEN1c3RvbWVycyk7XG4gIGNvbnN0IHByb2R1Y3RDYXRlZ29yeSA9IHVzZVByb2R1Y3RTdG9yZShzdGF0ZSA9PiBzdGF0ZS5wcm9kdWN0Q2F0ZWdvcnkpO1xuICBjb25zdCBzdG9yZUdlbmVyYXRlZENvbnRlbnQgPSB1c2VQcm9kdWN0U3RvcmUoc3RhdGUgPT4gc3RhdGUuZ2VuZXJhdGVkQ29udGVudCk7XG5cbiAgY29uc3Qgc3RhcnRFZGl0aW5nID0gdXNlQ2FsbGJhY2soKHNlY3Rpb25JZDogc3RyaW5nLCBpbml0aWFsQ29udGVudDogc3RyaW5nKSA9PiB7XG4gICAgc2V0RWRpdGluZ1NlY3Rpb24oc2VjdGlvbklkKTtcbiAgICBzZXRFZGl0ZWRDb250ZW50KGluaXRpYWxDb250ZW50KTtcbiAgICBzZXRJc0VkaXRpbmcodHJ1ZSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBjYW5jZWxFZGl0aW5nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldEVkaXRpbmdTZWN0aW9uKG51bGwpO1xuICAgIHNldEVkaXRlZENvbnRlbnQobnVsbCk7XG4gICAgc2V0SXNFZGl0aW5nKG51bGwpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgdXBkYXRlRWRpdGVkQ29udGVudCA9IHVzZUNhbGxiYWNrKChjb250ZW50OiBzdHJpbmcpID0+IHtcbiAgICBzZXRFZGl0ZWRDb250ZW50KGNvbnRlbnQpO1xuICB9LCBbXSk7XG5cbiAgY29uc3Qgc2F2ZUVkaXQgPSB1c2VDYWxsYmFjayhhc3luYyAoXG4gICAgc2VjdGlvbklkOiBzdHJpbmcsIFxuICAgIGdlbmVyYXRlZENvbnRlbnQ6IFByb2R1Y3REZXRhaWxDb250ZW50IHwgbnVsbCwgXG4gICAgc2V0R2VuZXJhdGVkQ29udGVudD86IChjb250ZW50OiBQcm9kdWN0RGV0YWlsQ29udGVudCkgPT4gdm9pZFxuICApID0+IHtcbiAgICBpZiAoIXNlY3Rpb25JZCB8fCBlZGl0ZWRDb250ZW50ID09PSBudWxsKSByZXR1cm47XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIOunjOyVvSDsmbjrtoDsl5DshJwg7KCE64us67Cb7J2AIGdlbmVyYXRlZENvbnRlbnTsmYAgc2V0R2VuZXJhdGVkQ29udGVudOqwgCDsnojri6TrqbQg7KeB7KCRIOyCrOyaqVxuICAgICAgaWYgKGdlbmVyYXRlZENvbnRlbnQgJiYgc2V0R2VuZXJhdGVkQ29udGVudCkge1xuICAgICAgICBjb25zdCB1cGRhdGVkQ29udGVudCA9IHsgLi4uZ2VuZXJhdGVkQ29udGVudCB9O1xuICAgICAgICBjb25zdCBzZWN0aW9uSW5kZXggPSB1cGRhdGVkQ29udGVudC5zZWN0aW9ucy5maW5kSW5kZXgocyA9PiBzLmlkID09PSBzZWN0aW9uSWQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHNlY3Rpb25JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICB1cGRhdGVkQ29udGVudC5zZWN0aW9uc1tzZWN0aW9uSW5kZXhdLmNvbnRlbnQgPSBlZGl0ZWRDb250ZW50O1xuICAgICAgICAgIHNldEdlbmVyYXRlZENvbnRlbnQodXBkYXRlZENvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyDqt7jroIfsp4Ag7JWK7Jy866m0IFp1c3RhbmQg7Iqk7Yag7Ja0IOyCrOyaqVxuICAgICAgICB1cGRhdGVTZWN0aW9uQ29udGVudChzZWN0aW9uSWQsIGVkaXRlZENvbnRlbnQpO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0b2FzdCh7XG4gICAgICAgIHRpdGxlOiAn7IiY7KCVIOyZhOujjCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAn7IS57IWYIOuCtOyaqeydtCDsl4XrjbDsnbTtirjrkJjsl4jsirXri4jri6QuJyxcbiAgICAgICAgdmFyaWFudDogJ2RlZmF1bHQnLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIO2OuOynkSDsg4Htg5wg7LSI6riw7ZmUXG4gICAgICBjYW5jZWxFZGl0aW5nKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRvYXN0KHtcbiAgICAgICAgdGl0bGU6ICfsiJjsoJUg7Iuk7YyoJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICfshLnshZgg64K07JqpIOyXheuNsOydtO2KuCDspJEg7Jik66WY6rCAIOuwnOyDne2WiOyKteuLiOuLpC4nLFxuICAgICAgICB2YXJpYW50OiAnZGVzdHJ1Y3RpdmUnLFxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbZWRpdGVkQ29udGVudCwgdXBkYXRlU2VjdGlvbkNvbnRlbnQsIGNhbmNlbEVkaXRpbmcsIHRvYXN0XSk7XG5cbiAgY29uc3QgcmVnZW5lcmF0ZVNlY3Rpb24gPSB1c2VDYWxsYmFjayhhc3luYyAoXG4gICAgc2VjdGlvbklkOiBzdHJpbmcsXG4gICAgZ2VuZXJhdGVkQ29udGVudD86IFByb2R1Y3REZXRhaWxDb250ZW50IHwgbnVsbCxcbiAgICBoYW5kbGVSZWdlbmVyYXRlPzogKHNlY3Rpb25JZDogc3RyaW5nKSA9PiB2b2lkXG4gICkgPT4ge1xuICAgIC8vIOyZuOu2gOyXkOyEnCDsoITri6zrkJwgZ2VuZXJhdGVkQ29udGVudOqwgCDsl4bri6TrqbQg7Iqk7Yag7Ja07JeQ7IScIOqwgOyguOyYtFxuICAgIGNvbnN0IGNvbnRlbnRUb1VzZSA9IGdlbmVyYXRlZENvbnRlbnQgfHwgc3RvcmVHZW5lcmF0ZWRDb250ZW50O1xuICAgIFxuICAgIGlmICghY29udGVudFRvVXNlKSB7XG4gICAgICB0b2FzdCh7XG4gICAgICAgIHRpdGxlOiAn7J6s7IOd7ISxIOyLpO2MqCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAn7IOd7ISx65CcIOy9mO2FkOy4oOqwgCDsl4bsirXri4jri6QuJyxcbiAgICAgICAgdmFyaWFudDogJ2Rlc3RydWN0aXZlJyxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBzZXRFZGl0aW5nU2VjdGlvbihzZWN0aW9uSWQpO1xuICAgIHNldElzRWRpdGluZygncmVnZW5lcmF0aW5nJyk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIOyZuOu2gOyXkOyEnCDsoITri6zrsJvsnYAg7ZW465Ok65+s6rCAIOyeiOuLpOuptCDsgqzsmqlcbiAgICAgIGlmIChoYW5kbGVSZWdlbmVyYXRlKSB7XG4gICAgICAgIGhhbmRsZVJlZ2VuZXJhdGUoc2VjdGlvbklkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIOq4sOyhtCDroZzsp4Eg7Iuk7ZaJXG4gICAgICAgIGNvbnN0IGNhY2hlTmFtZSA9IGNvbnRlbnRUb1VzZS5jYWNoZU5hbWUgfHwgJyc7XG4gICAgICAgIGNvbnN0IHByb2R1Y3ROYW1lID0gY2FjaGVOYW1lLnNwbGl0KCdfJylbMF0gfHwgJ1Byb2R1Y3QnO1xuICAgICAgICBcbiAgICAgICAgLy8gQVBJIO2YuOy2nFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlZ2VuZXJhdGVTZWN0aW9uQXBpKHtcbiAgICAgICAgICBzZWN0aW9uSWQsXG4gICAgICAgICAgcHJvZHVjdEluZm86IHtcbiAgICAgICAgICAgIG5hbWU6IHByb2R1Y3ROYW1lLFxuICAgICAgICAgICAgY2F0ZWdvcnk6IHByb2R1Y3RDYXRlZ29yeSBhcyBhbnksXG4gICAgICAgICAgICB0YXJnZXRDdXN0b21lcnMsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyDsnZHri7Ug7LKY66asIChBUEkg7J2R64u1IOq1rOyhsOyXkCDrp57qsowg7IiY7KCVKVxuICAgICAgICBpZiAocmVzcG9uc2UuZGF0YSAmJiByZXNwb25zZS5kYXRhLnNlY3Rpb25zICYmIHJlc3BvbnNlLmRhdGEuc2VjdGlvbnNbc2VjdGlvbklkXSkge1xuICAgICAgICAgIC8vIFp1c3RhbmQg7Iqk7Yag7Ja066W8IO2Gte2VtCDshLnshZgg7L2Y7YWQ7LigIOyXheuNsOydtO2KuFxuICAgICAgICAgIHVwZGF0ZVNlY3Rpb25Db250ZW50KHNlY3Rpb25JZCwgcmVzcG9uc2UuZGF0YS5zZWN0aW9uc1tzZWN0aW9uSWRdLmNvbnRlbnQpO1xuICAgICAgICAgIFxuICAgICAgICAgIHRvYXN0KHtcbiAgICAgICAgICAgIHRpdGxlOiAn7J6s7IOd7ISxIOyZhOujjCcsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ+yEueyFmCDrgrTsmqnsnbQg7IOI66Gt6rKMIOyDneyEseuQmOyXiOyKteuLiOuLpC4nLFxuICAgICAgICAgICAgdmFyaWFudDogJ2RlZmF1bHQnLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcign7IS57IWYIOyerOyDneyEsSDsi6TtjKgnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfshLnshZgg7J6s7IOd7ISxIOyYpOulmDonLCBlcnJvcik7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICfslYwg7IiYIOyXhuuKlCDsmKTrpZjqsIAg67Cc7IOd7ZaI7Iq164uI64ukJztcbiAgICAgIFxuICAgICAgdG9hc3Qoe1xuICAgICAgICB0aXRsZTogJ+yerOyDneyEsSDsi6TtjKgnLFxuICAgICAgICBkZXNjcmlwdGlvbjogZXJyb3JNZXNzYWdlLFxuICAgICAgICB2YXJpYW50OiAnZGVzdHJ1Y3RpdmUnLFxuICAgICAgfSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzRWRpdGluZyhudWxsKTtcbiAgICAgIHNldEVkaXRpbmdTZWN0aW9uKG51bGwpO1xuICAgIH1cbiAgfSwgW3N0b3JlR2VuZXJhdGVkQ29udGVudCwgcHJvZHVjdENhdGVnb3J5LCB0YXJnZXRDdXN0b21lcnMsIHVwZGF0ZVNlY3Rpb25Db250ZW50LCB0b2FzdF0pO1xuXG4gIHJldHVybiB7XG4gICAgZWRpdGVkQ29udGVudCxcbiAgICBpc0VkaXRpbmcsXG4gICAgZWRpdGluZ1NlY3Rpb24sXG4gICAgc3RhcnRFZGl0aW5nLFxuICAgIGNhbmNlbEVkaXRpbmcsXG4gICAgdXBkYXRlRWRpdGVkQ29udGVudCxcbiAgICBzYXZlRWRpdCxcbiAgICByZWdlbmVyYXRlU2VjdGlvbixcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwicmVnZW5lcmF0ZVNlY3Rpb25BcGkiLCJ1c2VQcm9kdWN0U3RvcmUiLCJ1c2VUb2FzdCIsInVzZUNvbnRlbnRFZGl0aW5nIiwiZWRpdGVkQ29udGVudCIsInNldEVkaXRlZENvbnRlbnQiLCJpc0VkaXRpbmciLCJzZXRJc0VkaXRpbmciLCJlZGl0aW5nU2VjdGlvbiIsInNldEVkaXRpbmdTZWN0aW9uIiwidG9hc3QiLCJ1cGRhdGVTZWN0aW9uQ29udGVudCIsInN0YXRlIiwidGFyZ2V0Q3VzdG9tZXJzIiwicHJvZHVjdENhdGVnb3J5Iiwic3RvcmVHZW5lcmF0ZWRDb250ZW50IiwiZ2VuZXJhdGVkQ29udGVudCIsInN0YXJ0RWRpdGluZyIsInNlY3Rpb25JZCIsImluaXRpYWxDb250ZW50IiwiY2FuY2VsRWRpdGluZyIsInVwZGF0ZUVkaXRlZENvbnRlbnQiLCJjb250ZW50Iiwic2F2ZUVkaXQiLCJzZXRHZW5lcmF0ZWRDb250ZW50IiwidXBkYXRlZENvbnRlbnQiLCJzZWN0aW9uSW5kZXgiLCJzZWN0aW9ucyIsImZpbmRJbmRleCIsInMiLCJpZCIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJ2YXJpYW50IiwiZXJyb3IiLCJyZWdlbmVyYXRlU2VjdGlvbiIsImhhbmRsZVJlZ2VuZXJhdGUiLCJjb250ZW50VG9Vc2UiLCJjYWNoZU5hbWUiLCJwcm9kdWN0TmFtZSIsInNwbGl0IiwicmVzcG9uc2UiLCJwcm9kdWN0SW5mbyIsIm5hbWUiLCJjYXRlZ29yeSIsImRhdGEiLCJFcnJvciIsImNvbnNvbGUiLCJlcnJvck1lc3NhZ2UiLCJtZXNzYWdlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/product-detail-viewer/hooks/useContentEditing.ts\n"));

/***/ })

});